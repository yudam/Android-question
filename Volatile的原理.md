
## 什么是原子操作？
不可中断的一个或者一系列操作。在多线程环境下，原子操作可以避免加上锁之类的操作。  
使用Synchronize和Lock修饰的内部代码都是原子操作，Java中一些类如AtomicInteger等也都是原子操作。这里需要注意的i++并不是原子操作.
```
  1.获取number的值
  2.将number变量的值+1
  3.将值写入主内存中
```
这里只有第一步属于原子操作。

## voliatile保证了可见性，有序性

### Java变量的读写
#### Java通过几种原子操作完成工作内存和主内存的交互：

lock：作用于主内存，把变量标识为线程独占状态。  
unlock：作用于主内存，解除独占状态。  
read：作用主内存，把一个变量的值从主内存传输到线程的工作内存。  
load：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中。  
use：作用工作内存，把工作内存当中的一个变量值传给执行引擎。  
assign：作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。  
store：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。  
write：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中。 

### volatile如何保持内存可见性  
volatile的特殊规则就是：

* read、load、use动作必须连续出现。
* assign、store、write动作必须连续出现。  

所以，使用volatile变量能够保证:

* 每次读取前必须先从主内存刷新最新的值。
* 每次写入后必须立即同步回主内存当中。  



也就是说，volatile关键字修饰的变量看到的随时是自己的最新值。线程1中对变量v的最新修改，对线程2是可见的。

## Synchronized同步锁
保证同一时刻只有一个线程可以访问。  
每个对象都有一个计数器，当获取对象锁后，计数器+1,释放锁后就会将计数器-1，所以当对象的计数器>0时，其它线程就只能等待。  

缺点：不能够设置锁超时时间，不能够通过代码释放锁，容易造成死锁。

## ReentrantLock 锁
ReentrantLock支持公平锁，中断锁操作，设置超时等待等，可以配合Condition来设置锁的的等待、唤醒机制。
* 公平锁：指的是当锁可用时，在锁上等待时间最长的线程将获得锁。构造ReentrantLock对象时传true就可以。
* 非公平锁：默认就是。随机分配使用权。
